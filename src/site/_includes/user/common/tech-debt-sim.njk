<div id="sim-container" style="border: 1px solid #444; padding: 20px; border-radius: 8px; font-family: monospace;">
    <h3>Technical Debt Simulator</h3>
    
    <div style="margin-bottom: 20px;">
        <label>Refactoring Allocation: <span id="refactor-val">30</span>%</label>
        <input type="range" id="refactor-slider" min="0" max="100" value="30" style="width: 100%;">
    </div>

    <div style="display: flex; gap: 10px; height: 150px; align-items: flex-end;">
        <div id="bar-velocity" style="width: 30%; background: #4caf50; text-align: center; color: white;">Feature Velocity</div>
        <div id="bar-debt" style="width: 30%; background: #f44336; text-align: center; color: white;">Tech Debt</div>
        <div id="bar-morale" style="width: 30%; background: #2196f3; text-align: center; color: white;">Team Morale</div>
    </div>
    
    <div id="sim-log" style="margin-top: 15px; font-size: 0.8em; color: #888;"></div>
</div>

<script>
(function() {
    // 1. PURE FUNCTIONS (Logic)
    // Calculate next state based on inputs. No side effects here.
    const nextState = (current, input) => {
        const debtGrowth = (100 - input.refactorRate) * 0.5;
        const debtReduction = input.refactorRate * 0.8;
        
        // Debt accumulates if you don't pay it down
        const newDebt = Math.max(0, current.debt + debtGrowth - debtReduction);
        
        // Velocity suffers as debt grows (The "Interest" payment)
        const debtDrag = newDebt * 1.2; 
        const rawVelocity = (100 - input.refactorRate); 
        const newVelocity = Math.max(0, rawVelocity - debtDrag);

        // Morale drops if Velocity is low (frustration) OR Debt is high (messy code)
        const newMorale = Math.max(0, 100 - (newDebt * 0.5) - ((100 - newVelocity) * 0.2));

        return {
            debt: Math.min(100, newDebt),
            velocity: Math.min(100, newVelocity),
            morale: Math.min(100, newMorale),
            input: input
        };
    };

    // 2. RENDER (Side Effects)
    // Pure visual updates based on state
    const render = (state) => {
        document.getElementById('refactor-val').innerText = state.input.refactorRate;
        
        // Update heights
        document.getElementById('bar-velocity').style.height = `${state.velocity}%`;
        document.getElementById('bar-velocity').innerText = `Vel: ${Math.round(state.velocity)}`;
        
        document.getElementById('bar-debt').style.height = `${state.debt}%`;
        document.getElementById('bar-debt').innerText = `Debt: ${Math.round(state.debt)}`;
        
        document.getElementById('bar-morale').style.height = `${state.morale}%`;
        document.getElementById('bar-morale').innerText = `Morale: ${Math.round(state.morale)}`;

        // Dynamic textual feedback
        const log = document.getElementById('sim-log');
        if (state.debt > 80) log.innerText = "CRITICAL: The team is paralyzed by legacy code.";
        else if (state.velocity > 80 && state.debt < 20) log.innerText = "OPTIMAL: Shipping fast with clean code.";
        else log.innerText = "System is running.";
    };

    // 3. RUNTIME (State Management)
    let state = { debt: 0, velocity: 100, morale: 100, input: { refactorRate: 30 } };
    
    // Initial Render
    render(nextState(state, state.input));

    // Event Listener
    document.getElementById('refactor-slider').addEventListener('input', (e) => {
        const input = { refactorRate: parseInt(e.target.value) };
        // Functional update: Old State + Input -> New State
        state = nextState(state, input); 
        render(state);
    });
})();
</script>